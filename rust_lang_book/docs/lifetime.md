# ライフタイム

- ライフタイムとは、参照が有効になるスコープのこと。
- Rustにおいて、参照はすべてライフタイム（有効になるスコープ）を保持している。
- ライフタイムの主な目的は、ダングリング参照を回避すること。
  - ダングリング参照により、プログラムは参照するつもりだったデータ以外のデータを参照してしまう。
- Rustコンパイラには、スコープを比較して、すべての借用が有効であるかをチェックする借用チェッカーがある

```rs
// rのライフタイムは'a、xのライフタイムは'b
// コンパイラは、2つのライフタイムのサイズを比較して、
// rは'aのライフタイムだが、xの'bのライフタイムのメモリを参照しており、
// 'bは'aよりも短いので、コンパイルエラーになる
fn main() {
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // ---------+
}
```

## ライフタイム注釈

- ライフタイム注釈は、アポストロフィー（`'`）で始まり、通常全部小文字で、ジェネリック型のようにとても短い
- 多くの人は、`'a`を使う

```rs
&i32  // ただの参照

&'a i32 // 明示的なライフタイム付きの参照

&'a mut i32 // 明示的なライフタイム付きのミュータブルな参照
```

## 関数シグネチャにおけるライフタイム注釈

- ジェネリック型の引数と同様に、関数名と引数リストの間に山カッコでライフタイム引数を宣言する

```rs
// longest関数は、xとyの正確なライフタイムを知っている必要はなく
// このシグニチャが満たすようなスコープを 'a に代入できることを知っているだけ
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

## 構造体定義のライフタイム注釈

- 構造体に参照を保持させる場合は、ライフタイム注釈をつける必要がある

```rs
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

## メソッド定義におけるライフタイム注釈

- メソッド定義にライフタイムをつける

```rs
impl<'a> ImportantExcerpt<'a> {
    // ライフタイムの省略ルールにのっとり、ライフタイム注釈は必要ないらしい
    fn level(&self) -> i32 {
        3
    }
}
```

## 静的ライフタイム

- `'static`という特殊なライフタイムがあり、参照がプログラムの全期間生存できることを意味する
- コンパイルエラー時に`'static`を使用するように勧められることもあるが、ダングリング参照を解消すればいいだけで、本当に全期間生存したほうがよいかは稽える必要がある

```rs
// 文字列リテラルはすべて'staticライフタイムになり、次のように注釈できる
let s: &'static str = "I have a static lifetime.";
```
